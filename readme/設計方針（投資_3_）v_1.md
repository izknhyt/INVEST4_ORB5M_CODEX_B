# FX自動売買ツール 全体設計方針（投資3）v1.0

最終更新: 2026-04-05 (Asia/Tokyo)

---

## 開発クイックリンク（Codex前提）
- **セッション手順**: `docs/codex_workflow.md` に 1ページのクイックスタートとテストマトリクスを集約。
- **状態同期の詳細**: `docs/state_runbook.md`（state.json 運用、アーカイブ、フォールバックパターン）。
- **タスク進行**: `docs/task_backlog.md`（DoD/優先度） ↔ `docs/todo_next.md`（次やること）。完了済み項目は backlog から即時除去。
- **進行中メモ**: `state.md`（Next Task / approvals / open questions）。Codex は着手前後で必ず参照。
- **テンプレート**: `docs/templates/next_task_entry.md` ・ `docs/templates/dod_checklist.md`。
- **改善ロードマップ**: `docs/development_roadmap.md`（即応タスクから長期施策までの道筋）。

以下は設計と判断基準のリファレンスとして維持する。手順面の更新は上記ドキュメントへ先行して反映する。

## 要約 / 決定事項（ADR要約）
- **2025-10-13更新: EVゲート暫定停止** — Phase4 での再調整期間は Day ORB を含む短期ストラテジーの `ev_mode` を `off` に設定し、EVプロファイル更新・aggregate_ev パイプラインを凍結。以下の ADR に記載された EV/ベイズ推定は長期目標として残しつつ、当面は ATR/ミクロ指標・日次本数・連敗ガードなどシンプルなリスクフィルタで運用する。
- **ADR-001 モジュラーモノリス + 明確なイベント境界**を採用。
  - 代替: マイクロサービス全面。**採用理由**: 初期開発速度とデバッグ容易性を優先しつつ、将来分割に備える。
- **ADR-002 言語方針: Python中心 + 執行/I/Oは将来Rust/C++で置換可能**
  - 代替: C++全面 or JVM中心。**採用理由**: 研究〜本番の一貫性と開発生産性の最大化。
- **ADR-003 バックテストはバー足先行 → 必要戦略のみTick精緻化**
  - 代替: 全戦略Tick精緻化。**採用理由**: 計算資源/時間の最適化と検証速度。
- **ADR-010 戦略は「単一エッジ=1プラグイン」**、**ルーターが時間帯・レジームでON/OFF/配分**
  - 代替: 万能戦略に条件分岐を内包。**採用理由**: 過学習回避・保守性・交換容易。
- **ADR-011 同時稼働≦5本、初期ポートフォリオ6–8本で開始**
  - 代替: 常時多数稼働。**採用理由**: 相関/キャパ/運用複雑度のバランス。

- **ADR-012 EV推定の既定法をアップグレード**（※2025-10-13 時点では検証停止中／長期目標扱い）
  - OCO=**Beta-Binomial**の勝率下限を用いて `EV_LCB = p_LCB×TP − (1−p_LCB)×SL − Cost`。
  - 可変利幅（トレール等）= **t分布の下側分位**（t-lower）で平均PnLの下限を採用。
  - 発注フィルタ: `EV_LCB ≥ 0.5 pip` 未満は見送り（往復コスト基準）。
  - EVプロファイル: state アーカイブ由来の長期/直近期統計で α/β・閾値補正を事前設定し、コールドスタート短縮とレジーム追従性を両立。
  - サイズ: **分数ケリー(0.25×)** を採用、リスク上限/日次DD/クールダウン等のガード併用。
  - 代替: 単純平均±SE。**採用理由**: 少数データ耐性と精度の両立。

- **ADR-013 適応的EVゲート**：目標ターンオーバー/資本使用率を維持するため、`threshold_lcb_pip`を自動調整（PID/二分探索）する。安全上限/下限を設け、日次で緩やかに更新。（現在はシンプル運用への移行に伴い停止中）
- **ADR-014 検証法の補強（全期間最適化 + パージド時系列CVは“ストレステスト”用途）**：主評価は2018–2025通しの単一設定。加えて**Purged-Embargoed K-fold**で“過剰最適化の兆候”のみ監視（パラメタ確定後に参照、再最適化には使わない）。
- **ADR-015 高精度Fillエンジン**：バー内順序不明のTP/SLは**Brownian Bridge近似**で到達順序確率を推定。保守モードとブリッジモードの**両方を合格**した戦略のみ採択。
- **ADR-016 部分プーリング（階層ベイズ）**：バケツ推定は全体平均へ緩やかに縮む（小サンプル過信の抑制）。
- **ADR-017 レジーム検知**：**CUSUM/BOCPD**によるドリフト検知で“注意”フラグを発報。ルーターのスコア減点に使い、ロジック自体は変更しない（過学習回避）。
- **ADR-018 ポートフォリオ配分**：戦略配分は**ボラターゲティング + EMCR（期待リスク貢献）**で決定。カテゴリ上限（Scal/Day/Swing = 40/40/20）を尊重。
- **ADR-019 データコントラクト**：OHLC/特徴量/約定ログに**スキーマ検証**（JSON Schema）を導入。欠損・逆転・タイムゾーン不整合をビルド時に停止。
- **ADR-020 再現性と監査**：**Artifacts Ledger**に“データ版/設定/乱数種/コミット/結果ハッシュ”を保存。レポートは自動でハッシュ署名。
- **ADR-021 自動アーカイブ/プロファイル更新**：state.json を `ops/state_archive` に蓄積し、CI/cron で `scripts/aggregate_ev.py` を実行して EV プロファイル (YAML/CSV) を最新化。Runner は起動時に自動ロードし、過去統計の適用を保証する（※シンプル化期間中は cron 実行を停止し、再導入時に再開予定）。
- **ADR-022 観測性強化**：EVプロファイルと実績PnLの乖離、バケット別通過率、コスト推定誤差を可視化するダッシュボード/ノートブックを標準化。閾値・サイズ調整の判断をトレースできるようログ/メトリクスを設計に含める。
- **ADR-023 設定分離とバージョン管理**：戦略パラメータ、EVプロファイル、リスク設定を YAML/JSON へ明示的に分離し、Git + ランIDでバージョン管理。実行時に使用した設定パスを成果物へ記録する。
- **ADR-024 拡張リスクフレーム**：トレード・日次に加え週次/累積DDやポートフォリオ VaR を設計に組み込み、配分・ゲート調整のルールと連携する。
- **ADR-025 回帰テスト強化**：ニュース凍結・高スプレッド・バケット未成熟などのゴールデンシナリオを定義し、シミュレーション/回帰テストで継続的に検証する。
- **ADR-035 ライブ値動きインジェスト基盤**：Streaming/REST を併用して最新価格を常時取り込み、`raw/`→`validated/`→`features/` の三層ストレージで検証・再サンプリングしつつ、5分ごとに `state.json` を更新するワーカーを常駐させる。
  - 補足: `run_daily_workflow.py --ingest --use-dukascopy` は `dukascopy_python` 経由で直近5分足を再取得し、`scripts/pull_prices.ingest_records` による冪等パイプラインへ直接流し込む。オンデマンド稼働でも最新バーを即座に反映できる。
  - 補足: 過去月のエクスポートは `scripts/merge_dukascopy_monthly.py --pattern 'USDJPY_2025??_5min.csv' --out data/usdjpy_5m_2025.csv` で結合し、一括バックフィルしてからライブ差分取得へ切り替える。
  - Codex Cloud Sandbox では企業プロキシにより PyPI（`dukascopy-python` / `yfinance`）への直接アクセスが遮断される制約があるため、`python3 scripts/run_daily_workflow.py --ingest --use-dukascopy --symbol USDJPY --mode conservative` 実行時は **Dukascopy → yfinance → ローカルCSV + `synthetic_local`** の順でフェイルオーバーが発動する設計を必須とする。運用ガイドは [README.md#オンデマンドインジェスト-cli](../README.md#オンデマンドインジェスト-cli) と [docs/api_ingest_plan.md](../docs/api_ingest_plan.md) を参照し、PyPI 依存導入後に改めて実データで鮮度検証を行う。
  - `scripts/check_benchmark_freshness.py` によるベンチマーク鮮度チェックは、Sandbox がローカル合成バーのみを使用している間は**情報提供目的（informational）**として扱い、本番導入前に再実行して閾値アラート解消を確認する。
- **ADR-036 ベースライン + ローリング検証ループ**：2018–2025 通しの基準 run を固定しつつ、直近1年/26週/90日をローリングで再シミュレーションするジョブを日次/週次で実行。`runs/index.csv` と `reports/` に比較結果を蓄積し、運用中の負け込みを即座に検証できるようにする。
- **ADR-037 マルチ戦略ポートフォリオ運用**：スキャル・デイ・スイング各カテゴリの戦略マニフェストを YAML 化し、ルーターがカテゴリ配分・相関・キャパを参照してON/OFF/サイズを決定する。戦略ごとに独立した state/EV/リスク予算を保持する。
- **ADR-038 健全性モニタリングとアラート**：state/EV/滑り推定/レイテンシのヘルスチェックを cron 化し、逸脱時は Webhook+ダッシュボードで通知。`ops/health/` に判定ログと直近シミュレーション結果を保存し、手動レビュー手順を runbook に統合する。
- **ADR-039 オンデマンド稼働対応**：常時稼働できない環境（例: ノートPC起動時のみ稼働）を想定し、インジェスト/検証/通知の各ジョブを idempotent な CLI バッチとして分離。前回成功時刻を記録し、起動時に空白期間を自動で再取得・再計算できるようにする。
- **ADR-040 GUI連携方針**：将来的なGUI化を見据え、CLIバッチ（ingest/state更新/ベンチマーク）のI/FとJSON出力を安定化。GUI側からは `run_daily_workflow.py` 等をサブプロセス起動し、標準出力のJSON/ログをパースして進捗表示・結果サマリを提示できるようにする。処理はバックグラウンドスレッド（ワーカー）で実行し、UIフリーズを避ける。

---

### 追加ADR（運用MVPの知見を反映）
- **ADR-026 単位正規化**：ATR/TP/SL/Costは常にpipsへ正規化し、`pip_size/price_to_pips`で一元管理。
- **ADR-027 セッションOR**：ORは“セッション開始から最初のN本”で確定（LDN/NY）。日次ではなくセッション境界を用いる。
- **ADR-028 EVウォームアップ**：初期N件は最小サイズでEV門をバイパスして学習を立ち上げ、速やかに通常運用へ移行。
- **ADR-029 アーティファクト台帳v1**：`runs/<id>/`に`params/metrics/records/daily`を保存し、`runs/index.csv`で横断追跡する。
- **ADR-030 ゲート較正**：`rv_band/spread_band`は銘柄×セッションの分位ベースで日次較正（固定値は初期推定）。
- **ADR-031 コストモデル拡張**：Spreadに加え、サイズ×帯域のスリッページと拒否率をEVに反映。SLO逸脱時は停止/減点。
- **ADR-032 Bridge部分学習**：Bridgeの`p_tp`をBetaに部分加点（α+=p_tp, β+=(1−p_tp)）。Conservativeは0/1更新。
- **ADR-033 可観測性/ファネル**：候補詳細`records.csv`と日次ファネル`daily.csv`を標準出力物とし、ゲート/EV/Fillの理由を記録する。
- **ADR-034 CLIランナー標準化**：CSV→Runner→成果物（metrics/records/daily）とラン保存（`--out-dir`）を標準I/Fとして提供。
- **ADR-035 EVハイブリッドプロファイル**：state アーカイブを集計して長期/直近期の期待値を YAML/CSV で管理し、Runner がバケット単位で α/β をシードして EV 閾値・サイズ判定を動的に補正する。

#### Sandbox Known Limitations
- Codex Cloud Sandbox は PyPI へのアウトバウンドが遮断されているため、`dukascopy-python` と `yfinance` の導入はホワイトリスト登録またはホイール持ち込みが完了するまで保留となる。その間は README の [オンデマンドインジェスト CLI](../README.md#オンデマンドインジェスト-cli) に記載した **Dukascopy → yfinance → ローカルCSV + `synthetic_local`** フェイルオーバーチェーンで運用する。
- ベンチマーク鮮度チェック（`python3 scripts/check_benchmark_freshness.py --target USDJPY:conservative --max-age-hours 6`）は合成バーのみの環境では参考情報扱いとし、依存導入後に再取得 → 再計測を実施する。再計測の要点は [docs/api_ingest_plan.md](../docs/api_ingest_plan.md) のフォールバック runbook を参照して同期する。
- 依存導入が可能になった段階で、`python3 scripts/run_daily_workflow.py --ingest --use-dukascopy --symbol USDJPY --mode conservative` と鮮度チェックを再実行し、実データでの遅延解消とスナップショット更新を確認する。

## 目的 / KPI
- 目的: デイトレ・スキャル・スイングの**低相関ポートフォリオ**を構築し、安定した超過収益を実現。
- 主要KPI（初期設定）
  - 年率リターン: **> 12%**（手数料/スリッページ込）
  - 年率ボラ: **< 10%**、最大DD（実現ベース）: **< 10%**
  - シャープ: **> 1.2**、Sortino: **> 1.5**
  - 実効手数料率: **< 30bps/回転**（ペア別管理）
  - レイテンシSLO: **スキャル決定<5ms/発注<20ms**, デイ<50ms, スイング<250ms

---

## スコープ / 非スコープ
- スコープ: FX現物（主要通貨ペア）; 研究→BT→リプレイ→ペーパー→小額実弾の段階リリース。
- 非スコープ（初期）: オプション/先物、マルチブローカー裁定、ニュース解析の学習モデル。

---

## アーキテクチャ原則
- 疎結合・高凝集。I/Oは端に隔離し**内向き依存**を徹底。
- **失敗前提設計**（タイムアウト/リトライ/冪等性/フォールバック）。
- **時系列リーク禁止**・**WFA/OOS**・**コスト/スリッページ/約定失敗のモデル化**は必須。
- **可観測性内蔵**（構造化ログ、メトリクス、トレース、アラート）。

---

## システム構成（概観）
```mermaid
flowchart LR
  subgraph Market[Data & Market Connectivity]
    F[Tick/OrderBook/Bar Feeds]
    B[Broker API]
  end
  subgraph Core[Trading Core]
    I[Ingestion & Cache\n(Tick→Bar/Feature)]
    FS[Feature Store\n(rolling/standardize)]
    STG[Strategy Engine\n(Plugins: Scal/Day/Swing)]
    RT[Strategy Router\n(Regime/Session/Quality)]
    RM[Risk Manager\n(Sizing/Constraints)]
    OMS[OMS/EMS\n(Orders/Routing/Retries)]
    EV[Event Bus\n(Pub/Sub)]
  end
  subgraph Eval[Evaluation & Control]
    BT[Backtester/Simulator\n(replay/slippage)]
    MON[Monitoring/Alerting\n(metrics/logs/traces)]
    RPT[Reporting]
  end
  F --> I --> FS --> STG --> RT --> RM --> OMS --> B
  STG <--> BT
  Core <--> MON
  BT --> RPT
  MON --> RPT
```


### 超かんたん版：値動きの読み取りの流れ
1) **生中継の価格**を受け取る（テレビの“生放送”のようなもの）
2) **直近だけ覚えておく箱**（リングバッファ）に一時保存（例: 直近5秒分）
3) **一定の時間ごとにまとめる**（1秒・1分などの“まとめ”＝バー）
4) **カンタンなメモを作る**（特徴量：
   - どれくらい揺れた？＝**ボラ**（RV/ATR）
   - 値段の勢いは？＝**トレンド**（ADXなど）
   - 今、買いと売りどちらが強い？＝**不均衡**、**スプレッド** など）
5) **司令塔（ルーター）**が「今はどの戦略が向いてるか」を決めて、実際の売買役（戦略）に渡す

> たとえ話：
> 生放送（価格） → メモ（特徴量） → キャプテン（ルーター） → ポジションを取る選手（戦略）

---

## 戦略ポートフォリオ方針
- カテゴリ: **スキャル**（100ms〜1s）, **デイトレ**（1m〜15m）, **スイング**（1h〜1D）。
- **MVP=3本 → V1=6–8本 → 成熟=10–18本**。ただし**同時稼働は3–5本**に制限。
- **レジーム適合**: ルーターが時間帯/流動性/ボラ/トレンド性/執行品質でON/OFF。
- 相関管理: 直近30Dの戦略PnL相関|ρ|>0.6は交互稼働 or 配分低減。


### レジーム検知の使い方（ADR-017）
- **何をするか**: CUSUM/BOCPDで“いつもと違う”を検知→**スコア減点**や**配分縮小**に反映。
- **何をしないか**: 自動でパラメタを変えない（**過学習の入口**になるため）。
- **見える化**: ダッシュボードに“注意フラグの時系列”と、その時の見送り/縮小理由をログ。

---

## Strategy API（共通I/F）
```python
class Strategy(ABC):
    api_version = "1.0"
    def on_start(self, cfg, instruments, state_store): ...
    def on_bar(self, bar): ...          # 1m/5m/15m/1h/4h/1D
    def on_tick(self, tick): ...        # scalping only
    def signals(self) -> Iterable[OrderIntent]: ...
    def eligibility(self, ctx) -> float: return 1.0  # 0..1 (regime gating)
    def capacity(self, ctx) -> float: ...            # safe size bound
    def risk_overrides(self, ctx) -> Optional[dict]: return None
    def on_stop(self): ...
```

### 戦略メタデータ（manifest例）
```yaml
id: scal_mr_v1
category: scalping
Timeframes: ["100ms","1s"]
eligible_sessions: ["LDN","NY"]
preconditions:
  max_spread_pips: 0.8
  min_book_depth_usd: 2_000_000
  min_rv_1m: 0.5
risk_budget_max: 0.20
max_concurrent_positions: 1
capacity_model: linear_vol
```

---

## Strategy Router（v0: ルールベース → v1: 学習化）
- **入力（未来情報禁止）**: 時間帯/曜日/セッション、スプレッド、板厚、実現ボラ(RV)、トレンド性簡易指標(ADX/Hurst proxy)、直近OR幅/当日レンジ比、執行品質（拒否率・滑り・レイテンシ）。
- **スコア**: `score = eligibility(ctx) * alpha_confidence`。
- **選択**: 同時稼働≦N（初期3–5）。カテゴリ配分上限: Scal 40% / Day 40% / Swing 20%。
- **安全装置**: 異常時はカテゴリ全体停止（例: スプレッド拡大、APIエラー急増）。

---

## データ要件 / スキーマ
- **履歴**: Parquet（UTC, symbol, tf, ohlcv, microstructure metrics）。1分/5分/1h/1Dロールアップ。
- **リアルタイム**: メモリRingBuffer + 短期Redisキャッシュ。
- **スリッページ/コスト表**: ブローカー×ペア×時間帯でバージョン管理。


### 値動きの読み取り（Feature設定）
- **タイムフレーム階層**: Scalping=100ms/1s, Day=1m/5m/15m, Swing=1h/4h/1D（UTC基準）。
- **マイクロストラクチャ**（可能ならLevel1/板サイズ使用）
  - `spread_pips=(ask-bid)*1e4`, `microprice=(ask*bid_sz + bid*ask_sz)/(bid_sz+ask_sz)`
  - `quote_imbalance=(bid_sz-ask_sz)/(bid_sz+ask_sz)`, `OFI`（Order Flow Imbalance 近似）
  - 約定方向（tick rule）と`signed_vol`、クオート更新レート
- **ボラ/トレンド/レンジ指標（リーク禁止の過去窓のみ）**
  - 実現ボラ（RV）: `sqrt(sum(r^2, window))`（年率換算）、ATR、Bipower Variation
  - トレンド性: MA傾き、ADX、Variance Ratio（Hurst近似）
  - 構造: Opening Range幅、レンジ圧縮（`OR/ATR`）、inside/outside bar比率
- **執行品質**: 拒否率、滑り（見積 vs 実績）、レイテンシ → ルーターの減点要素
- **Feature DSL（例）**
```yaml
feature_store:
  timeframes: { scalping: ["100ms","1s"], day: ["1m","5m"], swing: ["1h","4h","1D"] }
  windows: { zscore: 50, rv_1m: 60, adx: 14, atr: 14 }
  features:
    - name: spread_pips
      expr: (ask-bid)*1e4
      realtime: true
    - name: rv_1m
      expr: sqrt(sum(r_t^2, window=60))*sqrt(1440)
    - name: adx_14
      tf: 1m
      expr: ADX(high,low,close,14)
    - name: or_width_30m
      tf: 1m
      session: LDN
      expr: max(high, first_n=30) - min(low, first_n=30)
  gating_rules:
    - when: spread_pips < 0.8 and rv_1m > 0.5
      enable: ["scal_mr_v1"]
    - when: adx_14 > 18 and or_width_30m > pctl(or_width_30m, 60%)
      enable: ["day_orb_v1","swing_tr_v1"]
```
- **不変条件（テストで担保）**: 未来参照禁止・イベントタイム整列・欠損/異常値処理（winsorize/clip）・通貨単位/ピップス換算の統一。

#### 追補（MVP整合のための実装ガイダンス）
- 単位正規化（ADR-026）: 価格→pips変換を`pip_size/price_to_pips`に集約し、ATR/TP/SL/Cost/EVの入力単位を統一。
- セッションOR（ADR-027）: UTC→TOK/LDN/NYのマップ関数を設け、ORはセッション開始からN本で確定・境界でリセット。
- ゲート較正（ADR-030）: `rv_band/spread_band`はセッション分位で日次更新し、固定しきいは初期値とする。
- 可観測性（ADR-033）: ゲート/EV/Fillの各段で理由・指標を`records.csv`へ、日次ファネルを`daily.csv`へ標準出力。
- ラン保存（ADR-029/034）: `--out-dir`で`runs/<id>/`へ`params/metrics/records/daily`を保存、`runs/index.csv`にサマリ行を追記。

---

## データ検証ハンドブック（実務手順）
- 目的: バックテスト前に“データが戦える状態か”を自動で確認し、異常があれば即停止・修正を促す。

1) スキーマ検証（JSON Schema）
  - 必須キー: `timestamp,symbol,tf,o,h,l,c,v,spread`。
  - ルール: `tf=='5m'`, `l ≤ min(o,c)`, `h ≥ max(o,c)`, `l ≤ h`, `spread ≥ 0`。
  - 単位: spreadは価格単位（pipsではない）。
  - エラー例: `E001 missing_key`, `E002 type_error(number)`, `E003 price_inversion`。

2) 連続性チェック（5分足）
  - 手順: タイムスタンプ昇順→差分が常に5分であることを確認。
  - 例外: 週末/祝日/夏時間境界は許容（スキップ）するが、重複/逆順はNG。
  - エラー例: `E101 gap_detected`, `E102 duplicate_ts`, `E103 out_of_order`。

3) 値域・外れ値
  - 価格: 常識的レンジ外（ペア別の許容帯）を警告。極端スパイクは別表で手動レビュー。
  - 出来高(v): 未提供は0許容。提供される場合は非負で単調ではないこと（指標による）。

4) 単位整合（pips正規化）
  - 変換: `pip_size(symbol)` を使い `price→pips` の相互変換が往復一致することをサンプルで確認。
  - コスト: `cost_pips = spread_price/pip_size + expected_slip_pips`。

5) ログと停止基準
  - Blocker: スキーマ不一致/連続性破綻/価格逆転→ビルド停止。
  - Warn: 軽微な外れ値/疎な出来高→ログのみ（閾値超過で停止）。

付録: 5分連続性の擬似コード
```
prev=None
for row in bars_sorted:
  if prev and (row.ts - prev.ts) != 5min: error(E101)
  if row.ts == prev.ts: error(E102)
  assert row.l <= min(row.o,row.c) and row.h >= max(row.o,row.c)
  prev=row
```

---

## 研究ワークフロー（CLI活用）
- フェーズA: 通す（ファネル確認）
  - 低いEV閾値・緩いゲート、`--warmup N`でまずトレードを出す。
  - `daily.csv` で breakouts→gate→ev→fill の通過率を確認。
- フェーズB: 締める（現実化）
  - `--threshold-lcb` を 0.2 → 0.5、`--min-or-atr` を 0.5 → 0.6、`--allow-low-rv` を外す。
  - `rv_cuts` をセッション分位へ近づける。
- フェーズC: 形にする（保存・比較）
  - すべて `--out-dir runs/` で保存。`runs/index.csv` を勝率/総pips/pnl_per_tradeでソート。
  - Conservative/Bridgeを同条件で比較し、両立を目指す。

- Note (CSV hygiene): `scripts/run_sim.py --manifest ...` は manifest 側でシンボル/TF を決め打ちし、CSV が `timestamp,open,high,low,close` のみでも受け付ける。ヘッダ不足やシンボル欠落時は `{"error":"csv_format", ...}` を返し、誤ったフィードが Runner に到達しないよう抑止する（README “CLI（MVP）” を参照）。

### 継続運用ジョブ（ベースライン & ローリング）
- **定常ベースライン**: ORB core 設定で2018–2025通しを週次で再計算し、`runs/index.csv` の基準行を更新。差分は `reports/baseline_diff.json` に記録し、過去との乖離を監視する。
- **ローリング検証**: 直近365D/180D/90Dを day-of-week ずらしで再シミュレーションし、`reports/rolling/<window>/` にメトリクスを保存。勝率・Sharpe・DD のトレンド線をダッシュボード化し、負け込み時の一次切り分けに使う。
- **State健全性**: (長期方針) 最新 run 後に `ops/state_archive/<strategy>/<symbol>/<mode>/` へ state を保存し、直近N=5ファイルを `scripts/aggregate_ev.py --aggregate-recent N` で再集約。現在はシンプル運用移行中のため aggregate_ev を停止し、再導入時に監視フローを復旧する。
- **再現リプレイ**: 本番の負けトレードを `ops/incidents/` に記録し、該当期間を `run_sim.py --manifest ... --csv ... --start-ts ... --end-ts ...` で再生、state 差異を比較するテンプレートノートを `analysis/incident_review.ipynb` として維持する。

### オンデマンド起動ワークフロー
- **起動トリガー**: ノートPCを起動/ログインしたタイミングで `scripts/run_daily_workflow.py`（または Automator/launchd）を呼び出し、一連のジョブを順番に実行する。
- **データ補完**: `scripts/pull_prices.py` が前回成功時刻を `ops/last_ingest.json` に保持し、停止中の期間をヒストリカルAPI/CSVからまとめて取得して `raw/`→`validated/`→`features/` に追記する。
- **state 更新**: 取得したバーを時系列順に `scripts/update_state.py` が処理し、`BacktestRunner` の `load_state` → `run_partial` → `export_state` を繰り返して `ops/state_archive` と最新 `state.json` を更新する。途中で中断しても再実行で追いつけるよう冪等性を担保する。
- **検証とレポート**: 補完後に `scripts/run_baseline.py` と `scripts/run_rolling.py` を起動してベースライン/ローリング run を再計算し、差分レポートとヘルスチェック結果を Webhook へ通知する。
- **終了処理**: 成果物（metrics/daily/state/health）を `runs/` と `reports/` に保存し、次回起動時の再開地点を `ops/runtime_snapshot.json` に記録。オフライン中のギャップは次回起動で自動解消される。



### データ取得（ライブ/履歴）
- **ライブ（今の値動きの読み取り）**
  - ソース: ブローカーの**Streaming API**（WebSocket/Long-Poll）からBid/Ask（可能なら板）を受信。
  - パス: `market_feed -> ringbuffer(Δt≤5ms) -> bar_aggregator -> feature_store`。
  - 同期: **UTC**基準、NTPで時刻同期。障害時はRESTポーリングへフォールバック、再接続は指数バックオフ。
  - 正常性: ハートビート監視、スプレッド/更新レートの異常検知で**自動ゲート（ルーター減点→停止）**。
  - 集計: ティック→100ms/1s/1m…のローリングOHLCVとマイクロストラクチャ指標（spread、imbalance、RV等）を**その場で**計算。
- **履歴（バックテスト/リプレイ）**
  - 優先: ブローカー提供の履歴 or 一貫した外部ベンダーの**M1+Tick**。取得後に**自前で再サンプリング**しParquet保存。
  - クレンジング: 欠損/異常スパイク除去、週末・祝日の整合、サマータイム境界の確認。
  - 監査: `raw/`（供給元そのまま）→`normalized/`（UTC整列/列名統一）→`features/`（特徴量）を**不可逆にしない3層保管**。
  - 個人利用を念頭に、無料ティア（Alpha Vantage / Twelve Data 等）でのレート制限（例: 5req/min, 500req/日）内に収まるバッチ取得・再試行ポリシーを設計へ組み込む。
- **保存**: `Parquet + partition(symbol, timeframe, yyyy=, mm=)`、短期はRedisキャッシュ。
- **規模目安**: M1×2通貨×2018–2025 ≈ 850万バー（圧縮Parquetで数GB台）。Tickは数百GB想定（要サンプリング運用）。

### データソース選択肢と登録の要否
- **最小登録で始める現実解（推奨）**
  1) ブローカーの**デモ口座**（多くが無料）でStreaming APIを使用（ライブの“今”の値動き取得）。
  2) 公開/半公開の**ヒストリカル（M1+Tick）**を取得してバックテスト（例: ブローカー提供の履歴、公共系の履歴）。
  3) フォーマットを自前で正規化してParquet保管。Paper/LIVEに進むまでは**入出金不要**が一般的。
- **完全に無登録でのライブ取得**はFXでは現実的でないことが多い（価格配信は免責・約款が必要なため）。どうしても登録回避なら**履歴だけで開発→後段で最小登録**の段階移行が良い。
- **費用感**: デモ/開発段階のAPI利用は多くが**無料**。本番ではAPI自体の課金よりも**スプレッド/コミッション**が主コスト。機関系データベンダは有料（高額）。

### バーインジェスト方針（2025-10 更新）
- **一次経路**: `scripts/dukascopy_fetch.py` → `scripts/pull_prices.ingest_records` を用い、Dukascopy の M1/M5 履歴を `python3 scripts/run_daily_workflow.py --ingest --use-dukascopy` で定期取得。`ops/runtime_snapshot.json.ingest` と `raw/→validated/→features/` を冪等に更新し、鮮度チェック (`scripts/check_benchmark_freshness.py`) を 6h 以内に保つ。
- **REST/API ルート**: `scripts/fetch_prices_api.py` + `configs/api_ingest.yml` で Alpha Vantage FX_INTRADAY を試験実装済みだが、プレミアム専用エンドポイントのため 2025-10 時点では**保留**。再開条件（コスト/レート制限/提供データ粒度）は `docs/api_ingest_plan.md` に記録しておき、契約後にすぐ復帰できるようにする。
- **冗長化候補**: Dukascopy が落ちた場合は yfinance などの無料ソースから取得 → 正規化して `ingest_records` に流す adapter を準備する。形式差（タイムゾーン・列名・欠損）の吸収レイヤーを `scripts/yfinance_fetch.py`（仮）で提供し、`configs/ingest_backends.yml` で優先順位と許容差を管理する予定。
- **フォールバック順序**: ①Dukascopy → ②代替無料REST（yfinance 等） → ③有料REST（Alpha Vantage等、契約後再開）。各経路で記録する `ops/logs/ingest_anomalies.jsonl` にソース名を残し、切り替え判断を追跡可能にする。
- **実装状況 (2025-11-01)**
  - `scripts/run_daily_workflow.py --ingest` で `--use-dukascopy` / `--use-yfinance` を排他指定できる。Dukascopy 取得が失敗した際はオペレータが yfinance へ切り替え、`scripts/yfinance_fetch.py` が `period="7d"` で最新7日間を取得しつつ `start/end` でフィルタリングする。
  - yfinance アダプタはシンボル（USDJPY→JPY=X）と intraday 60日制限を吸収し、`ingest_records` へ冪等に流し込む。`ops/runtime_snapshot.json.ingest.USDJPY_5m` に最終タイムスタンプを記録し、`validated/` / `features/` が同じタイミングまで更新される。
- **今後の課題**
  - Dukascopy→yfinance の自動フォールバック（例: `--use-dukascopy --fallback-yfinance`）と、取得後に `datetime.utcnow()` との差分が閾値（案: 90〜120分）を超えた場合の NG 判定/アラートをワークフローへ組み込む。
  - Runbook にフォールバック運用手順・依存パッケージ (`yfinance`, `scipy`)・時刻乖離チェック手順を追記し、オンコールが即時参照できるようにする。
  - 将来的に REST/API ルートを再開する際は、同じ recency 検証とシンボル正規化ポリシーを流用する。

### 値動きの読み取り（Feature設定）
- **タイムフレーム階層**: Scalping=100ms/1s, Day=1m/5m/15m, Swing=1h/4h/1D（UTC基準）。
- **マイクロストラクチャ**（可能ならLevel1/板サイズ使用）
  - `spread_pips=(ask-bid)*1e4`, `microprice=(ask*bid_sz + bid*ask_sz)/(bid_sz+ask_sz)`
  - `quote_imbalance=(bid_sz-ask_sz)/(bid_sz+ask_sz)`, `OFI`（Order Flow Imbalance 近似）
  - 約定方向（tick rule）と`signed_vol`、クオート更新レート
- **ボラ/トレンド/レンジ指標（リーク禁止の過去窓のみ）**
  - 実現ボラ（RV）: `sqrt(sum(r^2, window))`（年率換算）、ATR、Bipower Variation
  - トレンド性: MA傾き、ADX、Variance Ratio（Hurst近似）
  - 構造: Opening Range幅、レンジ圧縮（`OR/ATR`）、inside/outside bar比率
- **執行品質**: 拒否率、滑り（見積 vs 実績）、レイテンシ → ルーターの減点要素
- **Feature DSL（例）**
```yaml
feature_store:
  timeframes: { scalping: ["100ms","1s"], day: ["1m","5m"], swing: ["1h","4h","1D"] }
  windows: { zscore: 50, rv_1m: 60, adx: 14, atr: 14 }
  features:
    - name: spread_pips
      expr: (ask-bid)*1e4
      realtime: true
    - name: rv_1m
      expr: sqrt(sum(r_t^2, window=60))*sqrt(1440)
    - name: adx_14
      tf: 1m
      expr: ADX(high,low,close,14)
    - name: or_width_30m
      tf: 1m
      session: LDN
      expr: max(high, first_n=30) - min(low, first_n=30)
  gating_rules:
    - when: spread_pips < 0.8 and rv_1m > 0.5
      enable: ["scal_mr_v1"]
    - when: adx_14 > 18 and or_width_30m > pctl(or_width_30m, 60%)
      enable: ["day_orb_v1","swing_tr_v1"]
```
- **不変条件（テストで担保）**: 未来参照禁止・イベントタイム整列・欠損/異常値処理（winsorize/clip）・通貨単位/ピップス換算の統一。


### 5分足モード（軽量運用）
- **取得**: 5分ごとにOHLCをRESTで取得（WebSocket必須ではない）。
- **保持**: メモリに**直近N=200〜1000本**（Pythonの`deque`/NumPyで軽量）。
- **永続化**: 5分バーを**Parquet**へ定期追記（CSVは遅く破損リスクがあるため非推奨）。
- **理由**: ライブ計算はメモリで高速、履歴はParquetで堅牢・検索容易。蓄積はそのまま**リプレイ**に使用可。


### データ契約（Data Contracts）
- **Schema**: `timestamp(UTC, ns)`, `symbol`, `tf`, `o,h,l,c`, `v`, `spread`, `rv`, 他派生。JSON Schemaで**型/範囲/単位**を厳格化。
- **検証**: 価格の**陰陽反転禁止**（`l<=o,c<=h`）、`spread>=0`、**時間連続性**（5分刻み）をCIでチェック。
- **パーティション**: `symbol=tf=yyyy/mm/dd` でParquetを分割、**小ファイル化防止**のため週/月単位でのコンパクション。
- **時刻同期**: NTP同期、DST境界の固定ルール、週末/祝日マスクを共有テーブル化。

### 5分足モード（軽量運用）
- **取得**: 5分ごとにOHLCをRESTで取得（WebSocket必須ではない）。
- **保持**: メモリに**直近N=200〜1000本**（Pythonの`deque`/NumPyで軽量）。
- **永続化**: 5分バーを**Parquet**へ定期追記（CSVは非推奨）。
- **リプレイ**: Parquetから**等間隔で再生**し、本番と同コードパスで評価。

---

## バックテスト設計
- **モード**: backtest | replay | paper | live（同一コードで切替）。
- **WFA**: 時系列分割（train→validate→OOS）。
- **指標**: 年率換算Return/Vol, Sharpe/Sortino, MaxDD, 勝率, 期待値, Turnover, 実効コスト, 滑り分布。
- **検定**: パーミュテーション/リサンプリングで過学習検出。


### 検証・実証計画（勝てるかの証明）
- **WFA/WFP**: 例）2018–2025のうち、`train=12m → validate=3m → OOS=3m`をローリング。ステップ=3m。OOSの合算で評価（チューニングはvalidateまで）。
- **OOSホールドアウト**: 直近12mは完全未使用の最終OOS。ここでGo/No-Go判定。
- **シミュレーション忠実度**
  - 成行: 次バーOpen ± 0.5*spread + `slippage(size, liquidity, vol)`
  - 指値: intrabarで`price<=low`/`>=high`を満たす場合に**確率充足**。`p_fill = clip(k1*trade_through/spread * liquidity_factor, 0, 1)`
  - ストップ/ブレイクアウト同様。**OHLC整合ランダム化**でヒット順序を乱択（保守版=ワーストケース/ランダム版=中立）。両モデルでロバスト性確認。
  - 約定失敗/拒否: 時間帯×サイズのベータテーブルからサンプリング。
- **コスト/滑り**: スプレッドの時刻依存テーブル + 価格インパクト（`a*(size/liquidity)^b*vol`）。
- **統計的有意性**
  - **PSR/DSR**: Probabilistic/Deflated Sharpe Ratioで選択バイアス補正。閾値: `PSR>0.95` かつ `DSR>0.7`（OOS）。
  - **SPA/White RC**: 候補群に対する優位性検定（ブートストラップはStationary/Blocks）。
  - サブサンプル堅牢性: レジーム別（高/低ボラ、東京/LDN/NY）で符号維持。
- **リスク・破綻確率**
  - ドローダウン分布のブートストラップ、**Risk of Ruin < 5%**（日次リバランス、サイズ制約下）。
  - ケリーの分数上限でサイジング上限を設定（例: 0.25×Kelly）。
- **ライブ移行ゲート**
  - Paper ≥ 30 取引日、**トラッキング誤差**（実滑り−想定）|平均| ≤ 2bps、拒否率/レイテンシがSLO内。
  - 小額実弾で`max_loss_trade≤0.25%`、`max_dd_day≤1%`、サーキット有効。
- **監視と劣化検知**: Feature分布のドリフト（KS検定）、勝率/ERのCUSUM、切替理由の監査ログ。
- **受入基準（DoD）**: OOS合算で `Sharpe≥1.2, MaxDD≤10%, PSR>0.95, DSR>0.7`、Paperで実装SLO達成。


### 検証・実証計画（2018–2025で大きくプラスかの検証）
- **期間**: 2018-01-01 〜 2025-09-12（会話日時）を全網羅。通貨はUSDJPY/EURUSDを必須、他は段階追加。
- **WFA/WFP ローリング**
  - 窓: `train=24m → validate=6m → OOS=6m`、ステップ=3mで前進。各サイクルの**OOSのみ**を縫い合わせて評価。
  - 直近12mは**完全ホールドアウト**（最終確認用）。
- **約定シミュレーション忠実度**
  - 成行: 次バーOpen ± 0.5×spread + 影響スリッページ。
  - 指値/ストップ: OHLC整合ランダム化＋確率充足（板/流動性依存の`p_fill`）。
  - 拒否率: 時間帯×サイズの経験テーブルからサンプル。
- **採択基準（全OOS合算）**
  - `年率Return ≥ 12%`、`MaxDD ≤ 10%`、`Sharpe ≥ 1.2`、`PSR>0.95 & DSR>0.7`。
  - 通貨別/レジーム別でも**符号維持**（一方通行の偶然を除外）。
- **Paper検証**
  - 30取引日以上、実スリッページ誤差|平均|≤2bps、拒否率とレイテンシがSLO内。
- **監視と劣化検知**: Feature分布ドリフト（KS）、勝率/ERのCUSUM、切替理由の監査ログ。


### ローリングWFAで「OOSだけ縫い合わせ」とは
- **WFA（Walk-Forward Analysis）**: 時間を前に歩かせながら、一定幅の学習→検証→**OOS（完全未学習区間）**で性能を測る方法。
- **OOSだけ縫い合わせ**: 各サイクルの**OOS区間の結果だけ**を時系列順に連結し、一本の“擬似ライブ成績”を作ること。チューニングに使った区間を混ぜないため、楽観バイアスを抑制できる。

例（窓= `train24m → val6m → OOS6m`, ステップ=3m）:
```
|<----24m train---->|<--6m val-->|<--6m OOS-->| step 3m → 次へ
                                           ^  この6mのみ採点
繰り返して OOS(1) + OOS(2) + ... を連結 = 擬似ライブのPL曲線
```
- 最後の**直近12m**は完全ホールドアウト。ここでGo/No-Go最終判定。

### 検証・実証計画（2018–2025で大きくプラスかの検証）
- 期間: 2018-01-01〜2025-09-12 を全網羅（USDJPY/EURUSD必須）。
- 約定シミュレーション: 成行=Open±0.5×spread+影響滑り、指値/ストップ=OHLC整合ランダム化＋確率充足、時間帯×サイズの拒否率モデル。
- 採択基準: `年率Return≥12%`, `MaxDD≤10%`, `Sharpe≥1.2`, `PSR>0.95 & DSR>0.7`（OOS合算）。
- Paper: ≥30取引日、実滑り差|平均|≤2bps、SLO内（拒否/レイテンシ）。


### 検証方針B（あなたの意見を反映：**全期間まとめて学習・評価**）
- **目的**: 年ごとに雰囲気が変わる相場でも通しで通用する“骨太な”ルールを選ぶ。
- **やり方（シンプル）**
  1) 2018-01-01〜2025-09-12を**全部まとめて**使い、**ひとつの設定**で学習/最適化。
  2) その設定のまま**全期間を通しで**シミュレーション（過去改ざんなし）。
  3) さらに**年ごとの健康診断**も併記（各年の成績・最大下げ幅・連敗）。
- **過度な“合わせすぎ”を防ぐ工夫**
  - ルールは**少数パラメータ**（例: 3〜5個）に制限、範囲も常識的な幅だけ。
  - スコアは**シンプル**（Sharpe/MaxDD/総利益の合成）で選ぶ。
  - **年ごと**・**セッションごと**の内訳が崩れていないかをチェック（どこか1点だけで稼いでいないこと）。
- **合格条件（全期間トータル）**
  - 純利益 > 0（手数料/滑り込）
  - CAGR ≥ 12%、Sharpe ≥ 1.2、MaxDD ≤ 10%
  - 年次成績：**プラス年の数が過半**、最悪年の損失が平均の1.5倍以内

> 補足：従来のWFAは“過去のある断面で設定→少し先を試す”というやり方。あなたの意見に合わせ、本プロジェクトでは**「通しで一発」**を主評価にし、WFAは**サブ報告**（参考）に格下げします。


### 検証法アップグレード（v1.1）
- **主評価**: 2018-01-01〜2025-09-12を**単一設定で通し**、年次“健康診断”を併記。
- **ストレステスト**: **Purged-Embargoed K-fold**（Lopez de Prado）で一般化性能の**兆候**を確認（再最適化には未使用）。
- **Fillエンジン二重化**: 
  - *Conservative*（保守）: 同バーTP/SLは不利側優先。
  - *Bridge*（近似）: **Brownian Bridge**でヒット順序確率を推定し期待充足率を算出。
  → **両方の成績が基準超え**を採択条件。
- **ドリフト監視**: CUSUMで性能低下を早期検知、アラートのみ（自動パラメタ変更はしない）。

---

## コスト/スリッページ/約定失敗モデル
- スプレッド基準 + 価格インパクト（impact_power: `a*(size/liquidity)^b*vol`）。
- 約定失敗: 時間帯とサイズに依存する拒否率モデル（ベータテーブル→随時更新）。

---

## リスク/ポジション管理
- サイジング: 固定割合 or ボラターゲティング（`size ∝ target_vol / realized_vol`）。
- 制約: 1トレード損失≤0.5%（初期）、日次DD≤2%、週次DD≤4%、連敗Nでクールダウン。
- ポートフォリオ: カテゴリ別リスク予算（例: 0.4/0.4/0.2）。
- **キルスイッチ**: 全注文取消/クローズ、ヘッジ、API切断。


### 戦略別 受入基準（合格ライン）
- **共通の絶対条件**: 期待値>0（手数料/滑り込）、2018–2025 OOS合算で総PL>0。
- **カテゴリ別KPI（初期値）**
  - **スキャル**: 期待値 ≥ +0.5 bp/取引、HitRate≥48% かつ PF≥1.05、Sharpe≥1.2、AvgHold<120s、拒否率≤2%、p95レイテンシ<20ms、実効コスト≤5bp、Turnover高。
  - **デイ**: 期待値 ≥ +2 bp/取引、Sharpe≥1.2、MaxDD≤8%、AvgHold 10–240m、p95滑り≤1.5×想定、日次DD上限1.5%。
  - **スイング**: 月次勝率≥55% または 月次PF≥1.1、Sharpe≥1.0（カテゴリ特性上やや緩め）、MaxDD≤10%、AvgHold 1–10日、週末/指標前ルール遵守。
- **相関とキャパ**: 30D戦略PnL相関|ρ|≤0.6、容量（枚数/スプレッド影響）を満たすこと。

### 重複シグナル対策 / カバレッジ管理
- **Signal Broker**層を導入：各戦略は**目標ポジション**を提案し、ブローカーが**合成・上限クリップ**して最終発注。
- **デデュープ規則**
  1) **クールダウン**: 同一シンボルで同方向の新規はΔt≥X（例: 3分）未満ならリジェクト。
  2) **相関ペナルティ**: 直近のエントリー系列相関が高い戦略は、低スコア側を停止/縮小。
  3) **優先度**: レジーム適合スコア×信頼度で上位Nのみ採用（N≤5）。
  4) **同一価格帯の競合**: 近接指値は1本にマージしサイズ合算、タグで内訳を保持。
- **カバレッジ表**: 戦略×(セッション, ボラ帯, トレンド性)のヒートマップを維持し、空白レジームがあれば**新規戦略の募集**、重複過多は**剪定**。


### 期待値ベース発注フィルタとサイズ可変（5分足/OCO・トレール対応）
- **定義（参考: EV再導入時に参照）**: `EV ≈ P(TP)×TP_pips − P(SL)×SL_pips − Cost_pips`、`Cost=スプレッド+滑り+手数料`。
- **推定法（既定）**
  - **OCO**: **Beta-Binomial**で勝率の**下側限界**`p_LCB`を算出 → `EV_LCB = p_LCB×TP − (1−p_LCB)×SL − Cost`。
  - **可変利幅/トレール**: EWMAで`mean/std/n_eff`を更新し、**t-下側分位**で`EV_LCB`を算出（外れ値に強い）。
  - **階層ベイズ/部分プーリング**は将来拡張（小サンプルの過信抑制）。
- **バケツ法（状況別学習）**: `keys=[session, spread_band, rv_band, trend_flag]`。各バケツでEWMA集計し、サンプル不足なら見送り。
- **発注フィルタ**: `EV_LCB ≥ 0.5 pip` を満たす時のみエントリ（往復コスト0.5pip想定）。
- **サイズ決定**
  1) **ベース**: `units_base = (risk_r * Equity) / (pip_value * stop_pips)`（損切幅でリスク一定化）。
  2) **強弱**: OCOは**分数ケリー**（`b=TP/SL`, `f* = p_LCB − (1−p_LCB)/b`, 係数0.25×、上限キャップ）。可変利幅は`EV_LCB`強度をシグモイドで連続スケール。
  3) **ガード**: 1トレード損失上限（例0.5%）、日次DD上限（例2%）、クールダウン、近接指値のマージ。

#### 設定YAML（雛形）
```yaml
ev_estimator:
  oco:
    mode: beta_binomial
    conf_level: 0.95
    decay: 0.02              # EWMA
    min_trades_per_bucket: 50
  trailing:
    mode: t_lower
    conf_level: 0.95
    decay: 0.02
cost_model:
  spread_source: live_or_bar_mid
  slippage_estimator: ewma
buckets:
  keys: [session, spread_band, rv_band, trend_flag]
  bands:
    spread_band: [narrow, normal, wide]
    rv_band: [low, mid, high]

gate:
  threshold_lcb_pip: 0.5

sizing:
  method: fractional_kelly
  kelly_fraction: 0.25
  risk_per_trade_pct: 0.25
  units_cap: 5.0x_base
```


### 適応的EVゲート & 配分（ADR-013/018）
- **EVゲート自動調整**: 目標`turnover/day`や`capital_utilization`を維持するよう、`threshold_lcb_pip`を日次で微調整（±0.1pip以内）。**下限0.5pip**・上限1.5pipなどの安全枠内で調整。
- **配分最適化**: 戦略iの目標ボラを`sigma_target`に合わせる**ボラターゲティング**、かつ**EMCR**でリスク貢献を均等化。
- **サイズ決定**: 分数ケリー（OCOは`p_LCB`、可変利幅は`EV_LCB`強度）＋**1トレード損失≤0.5%**、**日次DD≤2%**、**クールダウン**、**近接指値マージ**。
- **2025-10-13備考**: Phase4 シンプル化に合わせ、EVゲートは凍結中。`ev_mode="off"`・固定勝率(デフォルト0.55)を用いたサイズ計算＋ATRフィルタ/日次本数制限で運用する。

#### 2025-10-13 方針転換メモ
- Phase4 検証でEVゲート依存がトレード枯渇のボトルネックと判明したため、**当面はEV関連処理を停止**し、シンプルなリスクフィルタ（ATR帯・ミクロトレンド・日次本数上限）で運用する。
- `scripts/run_sim.py` は `auto_state=false / aggregate_ev=false / use_ev_profile=false / ev_mode="off"` で実行し、EVプロファイル再集計も凍結。期待値は日次レポート上の参考指標に格下げする。
- これに合わせて **Day ORB 5m の再開発を進める（Phase4 シンプル化リブート）**。第1段階は「シグナル発生条件の緩和」「連敗・日次DD監視などの単純ガード」「ポートフォリオ監視での停止条件」整備を目標とする。
- EV再導入は Phase4 リブートの成果を観測したのち、ローリング勝率や連勝連敗分布等を活用した**中周期のON/OFF判定ロジック**として再検討する。
- **懸念点**: 現状ロングランはトレード0件であり、フィルタ緩和・軽量ガード調整・モニタリングKPI定義（勝率/連敗/日次DDなど）を次サイクルで優先実施する必要がある。Bridgeモード等の派生マニフェストも同方針で要更新。

### 階層ベイズでのバケツ安定化（ADR-016）
- `bucket ~ Normal(μ_global, τ^2)`、`μ_global`は全体平均。小サンプルの`bucket`は自然に`μ_global`へ縮む→**暴れ防止**。

---

## 執行（OMS/EMS）
- 冪等注文ID（`strategy_id/signal_id/ts`）。
- タイムアウト/再送/部分約定処理、指値追従、IOC/FOK/TWAP/追随ポリシー。
- ローカルポジション簿とブローカー照合（心拍監視、差異自動修正）。
- **置換可能I/F**: Python実装→必要時にRust/C++へFFI置換。


### 高精度Fillエンジン（詳細）
- **OCO**: バー内で`low<=SL`と`high>=TP`が同時に成り立つ場合、
  - 保守: 先に不利側（SL）とみなす
  - Bridge: バー始値`S`, 高値`H`, 安値`L`から**橋過程**を仮定し`P(TP先)`を近似 → 期待充足
- **トレール**: ストップはバー確定毎に更新、`max(high_t−trail, SL0)`。
- **拒否率/滑り**: スプレッド帯×サイズのテーブルから確率サンプリング、実績で逐次更新（EWMA）。

---

## 可観測性 / 運用
- 構造化ログ: 注文ライフサイクル（生成→送信→受付→約定/失敗）。
- メトリクス: p50/p95/p99レイテンシ、PnL（実現/含み）、滑り、拒否率、稼働率、切替理由。
- アラート: DD閾値、連敗、APIエラー、レイテンシ逸脱、価格ギャップ。
- ランブック: 通信断/拒否増/異常ボラ時の手順、ロールバック手順。


### SLI/SLOとリリース判定
- **SLI**: 期待値誤差（実績−EV_LCB）、滑り誤差、拒否率、日次DD、相関、稼働率。
- **SLO**: |期待値誤差の月次平均|≤2bps、拒否率≤2%、日次DD≤2%、切替理由100%記録。
- **Release Readiness**: チェックリスト（データ契約OK、回帰テスト緑、OCO/Bridge両モード合格、監視・アラート設定完了、ランブック更新）。

---

## 品質 / テスト
- ユニット/プロパティ/回帰、統計的有意性テスト（再現リプレイ）。
- 主要ロジックCoverage目標70%。
- 再現性: 固定シード、環境記録（依存pkg/データ版/乱数源）。


### 追加テスト
- **Property-Based**: 価格単位/ピップス変換の双方向性、OCOの充足一意性、資産保存則（ポジション簿）。
- **回帰**: 固定乱数種・固定データで結果ハッシュが一致。
- **Chaos**: ネットワーク断/遅延/重複配信での自動復旧（冪等発注ID）。

---

## セキュリティ
- 秘匿情報は外部Vault、権限最小化、署名付き監査ログ。

---

## リリース計画
1. **MVP**: 3戦略（Scal MR / Day ORB / Swing Trend）、ルーターv0（ルールベース）、バー足BT。
2. **V1**: 6–8戦略、Tick精緻化（スキャルのみ）、ダッシュボード拡充、ペーパー→小額実弾。
3. **V2**: 10–18戦略、学習型ルーター、Rust/C++による執行最適化。

---

## 既知の制約
- 単一ブローカー前提から開始（多系冗長化はV1+）。
- ニュース・指標の自動理解は非対応（カレンダー近接フラグのみ）。

---

## ファイル/ディレクトリ初期案
```
repo/
  DESIGN_OVERVIEW.md            # 本書
  core/
    event_bus.py, clock.py, feature_store.py, risk_manager.py, oms.py, backtester.py
  strategies/
    scalping_mr.py, intraday_orb.py, swing_trend.py, __init__.py
  router/
    router_v0.py
  configs/
    portfolio.yml, broker.yml, slippage_tables/
  tests/
    test_strategy_api.py, test_backtest.py, test_oms.py
```

---

## 次アクション（最小の一歩）
- [ ] **Day ORB シンプル化リブート**: シグナル発火条件の緩和・連敗/日次DDガード・日次本数制限を試行し、2018–2025ロングランでトレード>0件かつ暫定KPIを満たす構成を再構築する。
- [ ] **モニタリングKPIの具体化**: 勝率・PF・連敗数・日次DDなどの停止条件を定義し、`docs/progress_phase4.md` とダッシュボードに反映。Codex Cloud セッション開始時に参照できるチェックリストを整備する。
- [ ] **Bridge/他マニフェスト更新**: Day ORB の新方針を適用し、Bridge モードを含む派生マニフェストで挙動差異を把握。比較レポートを残してポートフォリオ側の影響を評価する。
- [ ] **EV再導入計画の下ごしらえ**: 日次レポートにローリング勝率や期待値推定を残し、再導入可否を判断する指標を整理。aggregate_ev 再開時の手順（cron/ドキュメント）をドラフトしておく。
